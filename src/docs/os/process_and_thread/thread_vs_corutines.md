---
title: 线程和协程
icon: /assets/icons/article.svg
order: 6
category:
  - OS
date: 2025-09-25
---

## 1. 核心概念

- **并发 (Concurrency)**：同一时间段内交替推进多任务，关注“能同时应对很多事”
- **并行 (Parallelism)**：同一时刻在不同硬件资源上同时执行，关注“真的同时做很多事”
- **进程/线程/协程**：
  - **进程**：资源隔离与地址空间单位，由内核调度
  - **线程**：CPU 调度的基本单位，共享进程资源，由内核调度
  - **协程**：用户态的轻量并发实体，由语言/库运行时调度，通常复用少量线程（M:N）

## 2. 协程与线程的关系

- **调度者**：
  - 线程由内核调度，切换成本高（陷入内核、内核栈、可能的调度队列操作）
  - 协程由用户态运行时调度，切换成本低（切换用户栈/少量寄存器，或推进状态机）
- **栈与内存**：
  - 线程栈通常较大（MB 级，配置相关）
  - 协程栈更小，且可增长/分段（栈式模型）；或无独立栈（无栈模型）
- **阻塞语义**：
  - 线程可直接调用阻塞系统调用，不影响语义，但影响并发度与切换开销
  - 协程需要配合非阻塞 I/O/异步系统调用，否则会把承载协程的线程也阻塞

## 3. 栈式 vs 无栈 协程

- **栈式协程（stackful/fibers/绿色线程）**
  - 每个协程有独立用户栈；切换=保存/恢复 PC、SP 及必要寄存器
  - 可在任意深度调用处挂起/恢复，无需改写函数
  - 代表：Lua 协程、Windows Fibers、Boost.Coroutine、部分 M:N 运行时；Go 的 goroutine 也有独立可增长栈(由运行时调度)

- **无栈协程（stackless）**
  - 编译器把 `async/await` 挂起点改写为状态机；无独立栈
  - 只能在显式 `await` 处让出；切换成本更低，局部变量被打包进状态机
  - 代表：Rust `async/await`（`Future` 状态机 + 执行器）、Python `asyncio`、C# async/await(语义类似)

## 4. 用户态 vs 内核态：为什么重要

- **两套栈**：线程通常有用户栈与内核栈；系统调用/中断时切到内核栈
- **跨态成本**：由 `syscall`/`sysenter` 进入内核，需要保存/恢复寄存器、切换栈、影响 CPU 管线与缓存/TLB，且阻塞型调用会触发内核调度
- **协程优势**：协程之间的切换留在用户态，不触发上述成本；对 I/O 的跨态不可避免，但可通过非阻塞/异步接口减少次数与阻塞时间

## 5. 切换时保存的上下文（栈式协程类比线程）

- 必要项：PC/IP、SP（栈指针）、必要的通用寄存器（按 ABI 的非易失寄存器集合）、可选的帧指针 FP
- 视情况：FPU/SIMD 寄存器（常惰性保存）、标志寄存器、TLS 指针（若跨线程迁移需要运行时保证语义）
- 线程切换比协程更多：还会涉及内核调度结构、可能的页表/TLB 影响与中断屏蔽等

## 6. 性能与量级（参考，环境相关）

- 用户态协程切换：几十到百余纳秒级（实现差异大）
- 空系统调用往返：数百纳秒到微秒级
- 线程上下文切换：数微秒到十余微秒，受负载影响较大

协程收益的来源：

- 减少“为并发而进行的内核参与”（用户态调度）
- 更小/可增长栈与轻量任务对象，提升并发承载能力
- 与事件循环/IO 复用配合，降低系统调用频率（批量化提交/收割）

## 7. 并发与并行的适配

- **IO 密集**：优先并发（协程/异步），隐藏等待、提升吞吐。配合 `epoll/kqueue/IOCP/io_uring`
- **CPU 密集**：优先并行（多核、多线程/多进程），协程仅减少调度开销；需工作窃取/任务分块

## 8. 常见误区

- 线程≠并行，单核多线程也只是并发；协程更不是并行
- 协程不是“没有系统调用”；I/O 必须跨内核边界，只是方式不同
- 并发不一定更快：上下文切换、锁竞争、缓存失配都可能吞噬收益
- 在协程内做阻塞调用会拖累底层线程，降低并发度

## 9. 语言与生态概览

- **Rust**：`async/await` 编译为 `Future` 状态机（无栈）；由执行器（Tokio/async-std）`poll` 驱动；并行需多线程执行器或 `spawn_blocking`
- **Go**：goroutine + 调度器（G/M/P），独立可增长栈；对阻塞调用有运行时接管与 `netpoller`
- **C/C++**：可用 fibers/ucontext/Boost.Coroutine、libco 等实现栈式协程；C++20 `std::coroutine` 提供基础语义（更多依赖库支持）
- **Python**：`asyncio`/`await`（无栈），或 gevent/greenlet（更接近栈式/monkey patch I/O）
- **C#/.NET**：`async/await` 状态机 + 线程池；IOCP 下异步 I/O 高效

## 10. 设计与实践建议

- IO 走非阻塞/异步路径：减少阻塞调用与边界穿越；必要时批量化（`sendmmsg/recvmmsg`、`io_uring`）
- 任务粒度适中：过细→调度开销大；过粗→负载不均、延迟高
- 明确取消与超时语义：协程丢弃/取消要释放资源、避免泄漏
- 避免线程局部依赖：协程可能跨线程迁移；用任务上下文或运行时封装
- 以度量驱动优化：观察 CPU/IO 利用率、上下文切换数、锁等待、P95/P99 延迟

## 11. 一句话总括

协程是在用户态对“像线程一样”的并发进行轻量调度的抽象：要并发不必频繁求助内核，要并行仍需多核与线程；栈式/无栈两路实现，各有适配场景，但共同目标是以更低成本承载更多并发与更好响应性;
