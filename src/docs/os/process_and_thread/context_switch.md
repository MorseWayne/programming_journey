---
title: 线程的上下文切换
icon: /assets/icons/article.svg
order: 5
category:

- OS
date: 2025-08-23

---
## 概览

线程上下文切换是操作系统实现多任务并发的核心机制。它通过保存和恢复线程的运行状态，使得多个线程可以在单个CPU核心上“看起来像”同时运行。然而，这个过程会带来直接（CPU执行调度代码）和间接（CPU缓存失效）的性能开销。在高性能编程中，理解并设法减少不必要的上下文切换是一个非常重要的优化方向。

![线程的上下文切换](/reference/mindmaster/线程切换开销.svg)

## 什么是上下文(Context)

在计算机中，一个线程正在CPU上运行时，它依赖于一系列信息来正确执行。这些信息就是线程的**上下文**，主要包括：

1. **CPU 寄存器 (CPU Registers)**：这是最核心的部分。CPU内部有一些高速存储单元叫做寄存器，它们存放着线程运行时的关键信息。
    * **程序计数器 (Program Counter, PC)**：指向当前线程正在执行的指令的下一条指令的地址
    * **栈指针 (Stack Pointer, SP)**：指向线程当前调用栈的顶部
    * **通用寄存器**：存放着线程正在使用的变量、中间计算结果等
2. **线程的栈 (Thread Stack)**：包含了线程的局部变量、函数调用的记录等信息
3. **线程状态**：例如“运行中”、“就绪”、“等待”、“终止”等，这些状态由操作系统内核进行管理

## 什么是上下文切换(Context Switch)

**线程上下文切换**是指 CPU 停止执行当前正在运行的线程，转而去执行另一个线程的过程。在这个切换过程中，操作系统需要：

1. **保存当前线程的上下文**：将当前线程的 CPU 寄存器等信息保存到内存中（通常保存在一个叫做“线程控制块” TCB 的数据结构里）
2. **加载下一个线程的上下文**：从内存中读取下一个即将运行线程的上下文信息，并将其加载到 CPU 的寄存器中
3. **跳转执行**：将 CPU 的指令指针跳转到新加载线程上次被中断的位置，从而开始执行新的线程
这个过程完全由**操作系统内核 (OS Kernel)** 的**调度器 (Scheduler)** 来完成，对于应用程序本身是透明的

## 什么情况下会发生切换

上下文切换是现代多任务操作系统的基础，主要由以下几种情况触发：

1. **时间片用完 (Time Slice Expiration)**

   在抢占式多任务系统中，每个线程会被分配一个固定的CPU时间片（比如10毫秒）。当时间片用完后，即使线程还想继续运行，操作系统也会强制剥夺其CPU使用权，切换到另一个处于“就绪”状态的线程。这是保证所有线程都能获得执行机会、防止单个线程霸占CPU的公平性机制。

2. **线程主动阻塞 (Thread Blocking)**

   当正在运行的线程执行了一个会导致它无法继续前进的操作时，它会主动进入“等待”或“阻塞”状态。例如：

* 调用 `sleep()` 函数，主动休眠。
* 等待I/O操作（如读取文件、等待网络数据）。
* 尝试获取一个已经被其他线程占用的锁 (Lock/Mutex)。

   此时，CPU不能空闲着，调度器会立即选择另一个“就绪”的线程来运行。

3. **更高优先级的线程就绪 (Higher-Priority Thread Ready)**

   如果一个更高优先级的线程从“等待”状态变为“就绪”状态（比如它等待的数据来了），操作系统会立即中断当前正在运行的低优先级线程，转而执行这个更高优先级的线程。

4. **硬件中断 (Hardware Interrupt)**

   当硬件（如键盘、鼠标、网卡）完成某个任务时，会向CPU发送一个中断信号。CPU会暂停当前线程，去执行一个内核中的中断服务程序。在服务程序执行完毕后，可能会导致更高优先级的线程被唤醒，从而发生上下文切换。

## 上下文切换的代价

上下文切换虽然是必要的，但它并不是“免费”的，会带来显著的性能开销：

1. **直接开销 (Direct Cost)**

   **CPU时间消耗**：操作系统内核执行保存和加载上下文的代码本身需要消耗CPU时间。这个过程涉及到几十到几百条指令，虽然很快，但频繁发生就会累积成巨大的开销。

2. **间接开销 (Indirect Cost)** - **这通常是更大的性能杀手**

* **CPU 缓存失效 (Cache Invalidation)**：CPU为了加速访问，会将频繁使用的数据从慢速的内存加载到高速的L1、L2、L3缓存中。当线程A切换到线程B时，CPU缓存里存放的大多是线程A的数据。线程B开始运行时，很可能在缓存中找不到自己需要的数据（称为“缓存未命中” Cache Miss），导致它必须从慢得多的主内存中去读取。这个等待内存访问的过程会造成严重的性能下降。
* **TLB 失效**：TLB (Translation Lookaside Buffer) 是用于缓存虚拟地址到物理地址映射关系的专用缓存。上下文切换也可能导致TLB失效，增加地址翻译的时间。

## 如何减少上下文切换？

既然上下文切换有开销，我们在编程中应该有意识地减少它：

1. **无锁并发编程 (Lock-Free Concurrency)**：使用锁是导致线程阻塞和切换的常见原因。可以尝试使用CAS（Compare-And-Swap）等原子操作来代替锁，减少线程间的等待。
2. **使用协程 (Coroutine)**：协程（也叫用户态线程、纤程）是一种更轻量级的“线程”。它的切换由应用程序自己控制，不涉及操作系统内核，因此没有保存/加载CPU寄存器的开销，也不会导致CPU缓存失效。切换成本极低。
3. **合理设置线程数**：创建过多的线程（远超CPU核心数）并不会让程序更快，反而会因为大量的线程争抢CPU而导致频繁的上下文切换，降低整体性能。应根据任务类型（CPU密集型 vs. I/O密集型）来设置合理的线程池大小。
4. **减少锁的粒度和持有时间**：如果必须用锁，应让锁保护的代码范围（临界区）尽可能小，执行速度尽可能快，以减少其他线程的等待时间。
